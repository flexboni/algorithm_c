# 퀵 정렬 (Quick Sort)

O(N^2) 을 가지는 알고리즘은 데이터 갯수가 10만개 이상이 된다면 효율성이 너무 떨어지게 된다. 그렇기 때문에 더욱 빠른 정렬 알고리즘이 필요한데, 그 대표적인 알고리즘 중 하나가 **퀵 정렬** 알고리즘 이다. 퀵 정렬은 _대표적인 '분할 정복' 알고리즘으로 평균 속도가 O(N * logN) 이다._

퀵 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할하는 식으로 빠르게 정렬한다. 즉, **특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나눈다.**

## 문제

### 다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.

> 1, 10, 5, 8, 7, 6, 4, 3, 2, 9

## 문제 확인

    특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누면 어떨까?

## 해설

일반적으로 퀵 정렬에서는 _기준 값_ 이 있다. 이를 **피벗(Pivot)** 이라고 하는데, 보통 첫 번째 원소를 피벗 값으로 설정하고 사용한다. 다음과 같이 1이라는 값이 먼저 피벗 값으로 설정이 됐다고 생각해보자.

(1) 10 5 8 7 6 4 3 2 9

이 경우 1보다 큰 숫자를 왼쪽부터 찾고, 1보다 작은 숫자를 오른쪽부터 찾는다. 이 때 1보다 큰 숫자는 바로 10이고, 1보다 작은 숫자는 없다. 이 때 작은 값의 인덱스가 큰 값의 인덱스보다 작으므로 피벗 값과 작은 값의 위치를 바꾼다. 즉, 1과 1을 교환하므로 제자리 걸음이다.

**1** 10 5 8 7 6 4 3 2 9

따라서 위와 같이 구성되고, 이 때 피벗 값이었던 1의 왼쪽에는 1보다 작은 값이 존재하며 오른쪽에는 1보다 큰 값이 존재한다. 이어 왼쪽과 오른쪽에서 퀵 정렬을 순환적으로 수행한다.

**1** (10) 5 8 7 6 4 3 2 9

이 때 왼쪽은 없으므로 무시하고, 오른쪽에서는 피벗 값으로 10이 채택된다. 10보다 큰 값을 왼쪽 부터 찾고, 10보다 작은 값을 오른쪽부터 찾는다. 큰 값은 찾지 못하게 되며 작은 값으로는 바로 9를 찾을 수 있다. 이 때 작은 값의 인덱스가 큰 값의 인덱스 보다 작으므로 9와 10을 교환한다.

**1** **9** 5 8 7 6 4 3 2 **10**

따라서 위와 같이 구성되고, 이 때 피벗 값이었던 10의 왼쪽에는 10보다 작은 값이 존재하며 오른쪽에는 10보다 큰 값이 존재한다. 이제 이어서 왼쪽과 오른족에서 퀵 정렬을 순환적으로 수행한다.

...

1 4 2 3 **5** 6 7 8 9 10

이제 5를 기준으로 하여 5보다 작은 값은 왼쪽에 있고, 5보다 큰 값은 오른쪽에 있다. 이제 5의 왼쪽과 오른쪽에서 추가적으로 퀵 정렬을 수행한다.

1 (4) 2 3 5 (6) 9 7 8 10

위와 같이 퀵 정렬을 순환적으로 수행하면 반으로 쪼개 들어가면서 분할 정복식으로 정렬이 완료된다.

**1 2 3 4 5 6 7 8 9 10**

[이어서 6강으로~~](https://github.com/flexboni/algorithm_c/blob/master/6강/README.md)