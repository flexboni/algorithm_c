# 퀵 정렬 (Quick Sort) - 2

[참고 : 이전 강의 5강으로~](https://github.com/flexboni/algorithm_c/blob/master/5강/README.md)

</br>

[문제 소스 코드 확인](https://github.com/flexboni/algorithm_c/blob/master/4강/insertionSort.cpp)

## 시간 복잡도

위 소스코드를 보면 '키 값보다 작은 값을 만날 때까지' 반복하는 부분에서 j가 start 보다 클 때에 한해서만 반복문이 수행되도록 처리돼 있다. 이는 항상 왼쪽에 있는 값과 피벗 값을 교환하기 때문이다. 오른쪽에 있는 값은 피벗 값과 교환되지 않으므로 처리해 줄 필요가 없다. 퀵 정렬 알고리즘은 기본적으로 N 번씩 탐색하되 반으로 쪼개 들어간다는 점에서 'log N' 을 곱한 복잡도를 갖는다.

    퀵 정렬의 시간 복잡도
    O(N * log N)

하지만!! 퀵 정렬의 최악 시간 복잡도는 어떻게 될까?? 바로 O(N^2) 이다.

    퀵 정렬의 최악 시간 복잡도
    O(N^2)

따라서 알고리즘 대회에서 복잡도 O(N * log N) 을 요구하는 경우 퀵 정렬을 이용하면 틀리기도 한다.

</br>

### 도대체 왜 최악의 경우 시간 복잡도가 O(N^2) 일까?

## 문제

다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.
1 2 3 4 5 6 7 8 9 10

위와 같이 이미 정렬이 돼 있는 경우 퀵 정렬의 시간 복잡도는 O(N^2) 에 가깝다. 반면 삽입 정렬의 경우 위 문제가 매우 빠르게 풀어낼 수 있다. _즉, 정렬할 데이터의 특성에 따라서 적절한 알고리즘을 사용하는 것이 중요하다._

