# 다이나믹 프로그래밍(Dynamic Programming)

[[자세한 설명 보기]](https://blog.naver.com/ndb796/221233570962)

다이나믹 프로그래밍은 프로그래밍 대회를 준비하는 사람에게는 절대 피할 수 없는 숙명이다. 다이나믹 프로그래밍 문제는 종류가 굉장히 많으며 컴퓨터적인 사고력을 물어보기에 적합하다는 점에서 자주 출제되기 때문이다. **다이나믹 프로그래밍** 이란, _'하나의 문제는 단 한 번만 풀도록 하는 알고리즘'_ 이다. 한 번 푼 것을 여러 번 다시 푸는 비효율적인 알고리즘을 개선시키는 방법이기도 하다.

    하나의 문제를 단 한 번만 풀도록 하는 알고리즘 이다.

상당수 _분할 정복 기법은 동일한 문제를 다시 푼다는 단점_ 이 있다. (다만 분할 정복 기법은 '정렬'과 같은 몇몇 요소에 대해서는 동일한 문제를 다시 풀게 되는 단점이 없다. 그 예시로 퀵 정렬이나 병합 정렬은 매우 빠르다.) 단순 분할 정복으로 풀게 되면 심각한 비효율성을 낳는 대표적인 예로 '피보나치 수열'이 있다. **피보나치 수열** 은 _특정한 숫자를 구하기 위해 그 앞에 있는 숫자와 두 칸 앞에 있는 수자의 합을 구해야 한다._

    피보나치 수열의 점화식

    D[i] = D[i-1] + D[i-2]

위 공식에 따라 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ... 와 같이 나아갈 수 있는 것이다. 만약 단순 분할 정봅 기법을 이용해 15번째 피보나치 수열을 구한다고 가정해보자. D[15]를 구하려면 D[14]와 D[13]을 알아야한다. 또한 D[14]를 알려면 D[13], D[12]를 알아야한다.(반복..)

따라서 이런 경우에 병합 정렬을 할 때 처럼 단순한 분할 정복 기법을 사용하면 안된다. 왜냐하면 _이미 해결한 문제를 다시 반복적으로 해결하는 비효율성이 발생하기 때문이다._

    다이나믹 프로그래밍

    가정1. 큰 문제를 작은 문제로 나눌 수 있다.
    가정2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

즉, 쉽게 말해 크고 어려운 문제가 있으면 그것을 먼저 잘게 나누어서 해결한 뒤에 처리하여 나중에 전체의 답을 구하는 것이다. 다만 이 과정에서 **'메모이제이션(Memoization)'** 이 사용된다는 점에서 분할 정복과 다르다. 이미 계산한 결과는 배열에 저장함으로써 나중에 동일한 계산을 해야 할 때는 저장된 값을 단순히 반환하기만 하면 되는 것이다.

---

[[소스 확인]](https://github.com/flexboni/algorithm_c/blob/master/21강/dynamicProgramming.cpp)

---