# 병합 정렬 (Merge Sort)

병합 정렬도 대표적인 _'분할 정복' 방법을 채택한 알고리즘이다._ 결과적으로 퀵 정렬과 동일하게 O(N * logN)의 시간 복잡도를 갖는다.

다만 퀵 정렬 피벗 값에 따라 편향되게 분할할 가능성이 있다는 점에서 _최악의 경우 O(N^2)의 시간 복잡도를 갖는다._ 병합 정렬은 정확히 반절씩 나눈다는 점에서 _최악의 경우에도 O(N * logN)을 보장한다._

병합 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할한 뒤에 각자 계산하고 나중에 합치는 방법을 채택한다. **즉, 기본 아이디어는 일단 정확히 반으로 나누고 나중에 정렬하는 것이다.** 

퀵 정렬과 다르게 피벗 값이 없고 항상 반으로 나눈다는 특징으로 단계의 크기가 logN이 되도록 만들어준다. 예시를 살펴보자.

<img width="693" alt="스크린샷 2020-07-09 오전 9 46 55" src="https://user-images.githubusercontent.com/29271126/86985533-704ff980-c1cc-11ea-8699-e532341016be.png">

위 사진을 보면 7 6 5 8 3 5 9 1인 모두 크기가 개별 배열로, 즉 크기가 1인 배열 상태로 시작한다.

1 단계에서는 각 배열의 크기가 2개이다. 크기가 1개였던 것들을 두 개씩 묶어서 합친 것이다. 6/7, 5/8, 3/5, 1/9 이다.

2 딘계에서는 2개였던 것들을 또 두 개씩 묶어서 크기가 4인 배열을 만든다.

다시 말해 **합치는 순간에 정렬을 수행하는 것이다.** 합치는 단계는 오직 3 단계면 된다. 합치는 갯수가 2배씩 증가한다는 점에서 2^3 = 8 이므로 3 단계만 필요한 것이다. 그러므로 단계의 크기는 데이터의 갯수가 N개 일 때 logN을 유지하게 된다. 또한 정렬 자체에 필요한 수행시간은 N이다. 데이터의 갯수 만큼만 연산하면 되기 때문이다. 결과적으로 *총 시간 복잡도는 O(N * logN)*이다.

그런데 왜 정렬에 필요한 수행시간이 N 밖에 되지 않을까?

<img width="588" alt="스크린샷 2020-07-09 오전 9 52 24" src="https://user-images.githubusercontent.com/29271126/86985538-71812680-c1cc-11ea-8eb7-7c82634fda35.png">


왼쪽 집합에서는 i 가 첫 번째 원소를 가리키고, 두 번째 집합에서는 j 가 두 번째 원소를 가리킨다. 그리고 정렬될 배열은 비어있는 상태이다. 정렬에 N 만 걸리는 이뉴는 삽입 정렬과 동일한 이유이다. 바로 **'부분 집한은 이미 정렬이 되어 있는 상태' 라고 가정하기 때문이다.** 이지 정렬이 되어 있는 것 두 개 합치는 것은 *시간 복잡도 O(N)* 이면 충분하기 때문이다.

<img width="603" alt="스크린샷 2020-07-09 오전 9 55 56" src="https://user-images.githubusercontent.com/29271126/86985541-7219bd00-c1cc-11ea-8f7f-a34f8e97ded3.png">

첫 번째 처리는 위와 같이 i 와 j 를 비교해서 더 작은 숫자를 k 의 위치에 넣고 처리한 인덱스를 1씩 더해주는 것이다. 그 결과 위와 깉아 k, j 가 한 칸 오른쪽으로 간 것을 알 수 있다.

<img width="603" alt="스크린샷 2020-07-09 오전 9 57 30" src="https://user-images.githubusercontent.com/29271126/86985542-72b25380-c1cc-11ea-86c9-d68887ec30ac.png">

마찬가지로 i = 6, j = 8 을 비교해서 6이 더 작으므로 k 의 위치에 삽입하고 i, k 를 각각 1씩 더해주는 것이다. 이런 식으로 반복하게 되면 정확히 *N 번만* 처리하면 된다.

<img width="693" alt="스크린샷 2020-07-09 오전 9 58 46" src="https://user-images.githubusercontent.com/29271126/86985544-734aea00-c1cc-11ea-9f2c-ddcdf9fab881.png">

즉, 위와 같이 너비가 N 번, 높이가 logN 번 이므로 시간 복잡도 O(N * logN)을 보장하는 것이다.

## 문제

다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.

    7 6 5 8 3 5 9 1

## 문제 확인

    일단 반으로 나누고 나중에 합쳐서 정렬하면 어떨까?

---

[[소스 확인]](https://github.com/flexboni/algorithm_c/blob/master/8강/mergeSort.cpp)

---

### 주의

병합 졍렬을 구현할 때 신경써야 하는 부분은 반드시 정렬에 사용되는 배열은 *'전역 변수'* 로 선언해야 한다는 것이다. 만약 함수 안에서 배열을 선언하게 된다면 매 번 배열을 선언해야 한다는 점에서 메모리 자원의 낭비가 매우 커질 수 있다. 이와 같이 기본적으로 **'기존의 데이터를 담을 추가적인 배열 공간이 필요하다'** 는 점에서 _메모리 활용의 비효율 문제가 발생한다._

## 요약

    병합 정렬의 시간 복잡도는 O(N * logN) 이다.

일반적인 경우 퀵 정렬보다 느리지만 어떤 상황에서도 정확히 O (N * logN) 을 보장할 수 있다는 점에서 몹시 효율적이다.