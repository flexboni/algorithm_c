# 힙 정렬(Heap Sort)

힙 정렬(Heap Sort)은 병합 정렬(Merge Sort)와 퀵 정렬(Quick Sort)마늠 빠른 정렬 알고리즘 이다. 또한 실제 고급 프로그래밍 기법으로 갈수록 힙(Heap)의 개념이 자주 등장하기에 반드시 알고 넘어가야하는 개념이다. **힙 정렬** 은 _힙 트리 구조(Heap Tree Structure)를 이용하는 정렬 방법이다._

    힙(Heap)을 이용해 데이터를 정렬하면 어떨까??

따라서 이진 트리(Binary Tree)를 먼저 알고, 힙(Heap)이 무엇인지 알아야 한다. **이진 트리** 란 _컴퓨터 안에서 데이터를 표현할 때 데이터를 각 노드(Node)에 담은 뒤에 노드를 두 개씩 이어 붙이는 구조를 말한다._ 이 때 트리 구조에 맞게 부모 노드에서 자식 노드로 가지가 뻗힌다. 모든 노드의 자식 노드가 2개 이하인 노드이다.

![image](https://user-images.githubusercontent.com/29271126/88005410-53a8af80-cb44-11ea-8b54-ebda084d6815.png)

(출처 : https://coderkoo.tistory.com/9)

위와 같은 구조를 이진 트리라고 한다. 여기서 트리(Tree) 라는 것은 말 그대로 가지를 뻗어 나가는 것처럼 데이터가 서로 연결돼 있다는 것이다.

![image](https://user-images.githubusercontent.com/29271126/88005579-aaae8480-cb44-11ea-97e9-be2aeab5e5c1.png)

(출처 : https://m.blog.naver.com/ndb796/221228342808)

**완전 이진 트리** 는 _데이터가 루트(Root) 노드부터 시작해서 자식 노드가 왼쪽 자식 노드, 오른쪽 자식 노드로 차근차근 들어가는 구조의 이진 트리이다. 즉, 완전 이진 트리는 이진 트리의 노드가 중간에 비어있지 않고 빽빽히 가득 찬 구조이다._ 위 사진 처럼 항상 왼쪽 자식 노드부터 데이터가 들어가는 구조이다.

**힙(Heap)** 은 _최소값이나 최댓값을 빠르게 찾아내기 위해 완전 이진 트리를 기반으로 하는 트리이다._ 힙에는 최대 힙과 최소 힙이 존재하는데 **최대 힙** 은 _'부모 노드'가 '자식 노드'보다 큰 힙_ 이라고 할 수 있다. 일단 힙 정렬을 하기 위해서는 정해진 데이터를 힙 구조를 가지도록 만들어야 한다.

![image](https://user-images.githubusercontent.com/29271126/88005958-869f7300-cb45-11ea-8cac-807558befcb1.png)

(출처 : https://www.crocus.co.kr/1184)

다만 트리 안에서 특정 노드 때문에 최대 힙이 붕괴되는 경우도 있다.

![image](https://user-images.githubusercontent.com/29271126/88006047-bcdcf280-cb45-11ea-9b31-3f04eac9fc05.png)

(출처 : https://m.blog.naver.com/ndb796/221228342808)

위와 같이 전체를 보면 중간에 있는 데이터 5를 가지는 노드 때문에 최대 힙이 아니지만 그 위 쪽으로는 최대 힙이 형성되고, 아래쪽은 최대 힙이 되지 않는다.

힙 정렬을 수행하기 위해서는 **힙 생성 알고리즘(Heapify Algorithm)** 을 사용한다. 힙 생성 알고리즘은 _특정한 '하나의 노드'에 대해서 수행하는 것이다. 또한 해당 하나의 노드를 제외하고는 최대 힙이 구성되어 있는 상태 라고 가정한다는 특징이 있다._ 위 그림과 같이 5에 대해서만 최대 힙 정렬을 수행 해주면 전체 트리가 최대 힙 구조로 형성 되는 상태를 예로 들 수 있다.

힙 생성 알고리즘(Heapify Algorithm)은 _특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 바꾸는 알고리즘이다. 또한 위치를 바꾼 뒤에도 여전히 자식이 존재하는 경우 또 자식 중에서 더 큰 자식과 자신의 위치를 바꾸어야 한다._ 즉, 위 예시에서 5의 두 자식인 7과 4 중에서 더 큰 자식인 7과 5를 바꾸는 것이다.

## 시간 복잡도

한 번 자식 노드로 내려갈 때마다 노드의 갯수가 2배씩 증가한다는 점에서 O(log N) 이다.

    힙 생성 알고리즘(Heapify Algorithm) 시간 복잡도 : O(log N)

전체 데이터의 갯수가 N개 일때 전체 트리를 힙 구조로 만드는 복잡도는 O(N * log N) 이다.

    힙 정렬 전체 시간 복잡도 : O(N * log N)

## 문제

다음의 데이터를 오름차순 정렬하세요.

    7 6 5 8 3 5 9 1 6

## 문제 확인

기본적으로 완전 이진 트리를 표현하는 가장 쉬운 방법은 배열에 그대로 삽입하는 것이다. 모든 원소를 기준으로 힙 생성 알고리즘을 적용해 전체 트리를 힙 구조로 만들어준다.

---

[[소스 확인]](https://github.com/flexboni/algorithm_c/blob/master/11강/heapSort.cpp)

---

힙 정렬은 병합 정렬과 다르게 별도로 추가적인 배열이 필요하지 않다는 점에서 메모리 측면에 효율적이다. 또한 항상 O(N * log N) 을 보장할 수 있다는 점에서 강력한 알고리즘이다. 즉, 이론적으로는 퀵 정렬, 병합 정렬보다 우위에 있다고 할 수 있다. 하지만 단순히 속도만 가지고 비교하면 퀵 정렬이 평균적으로 더 빠르기 때문에 힙 정렬이 일반적으로 많이 사용되지는 않는다.

## 보충 자료

최대 힙을 활용한 오름차순 정렬에서 힙 생성 함수(Heapify)는 특정한 노드를 기준으로 위쪽으로 올라가는 **상향식 구현 방식** , 아래쪽으로 내려가는 **하향식 구현 방식** 이 있다. 두 방식 모두 시간 복잡도는 동일하다.

### 문제

다음과 같이 출력 되도록 하는 프로그램을 작성하시오.

61 48 59 26 19 11 37 15 1 5
59 48 37 26 19 11 5 15 1 61
48 26 37 15 19 11 5 1 59 61
37 26 11 15 19 1 5 48 59 61
26 19 11 15 5 1 37 48 59 61
19 15 11 1 5 26 37 48 59 61
15 5 11 1 19 26 37 48 59 61
11 5 1 15 19 26 37 48 59 61
5 1 11 15 19 26 37 48 59 61
1 5 11 15 19 26 37 48 59 61

---

[[소스 확인]](https://github.com/flexboni/algorithm_c/blob/master/11강/extraHeapSort.cpp)

---