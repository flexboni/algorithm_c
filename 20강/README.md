# 이진 트리의 구현과 순회(Traversal) 알고리즘

[[자세한 설명 보기]](https://blog.naver.com/ndb796/221233560789)

기본적으로 가장 많이 사용되는 비선형 자료구조는 **이진 트리(Binary Tree)** 이다. 이진 트리는 트리 자료구조를 활용한 대표적인 예시로 _데이터의 탐색 속도 증진을 위해 사용하는 구조_ 이다. 실제로 트리를 제대로 구현하기 위해서는 '포인터(Pointer)' 를 사용해야 한다. 포인터를 이용해 특정한 루트(Root)에서 자식 노드로 접근할 수 있기 때문이다.

![image](https://user-images.githubusercontent.com/29271126/88507231-e949b080-d016-11ea-9ec6-13dd00969220.png)

이진 트리의 구조이다. 하나의 도느는 모두 왼쪽 자식과 오른쪽 자식을 가질 수 있도록 설계 돼 있다.

## 왜 '포인터'를 사용하는 것인가?

힙 정렬을 구현할 때는 '완전 이진 트리(Complete Binary Tree)'가 사용되었기 때문에 배열로 표현할 수 있지만 완전 이진 트리가 아닌 이진 트리는 배열로 표현하기 어렵기 때문이다. 포인터를 사용해 이진트리를 구현하는 경우 굉장히 유동적으로 트리 자료구조를 활용할 수 있다.

## 이진 트리 탐색 방법

### 전위 순회 (Preorder Traversal)

    하나의 노드에 방문했을 때 다음의 순서를 따른다.

    1. 자기 자신을 처리한다.
    2. 왼쪽 자식을 방문한다.
    3. 오른쪽 자식을 방문한다.

### 중위 순회 (Inorder Traversal)

    하나의 노드에 방문했을 때 다음의 순서를 따른다.

    1. 왼쪽 자식을 방문한다.
    2. 자기 자신을 처리한다.
    3. 오른쪽 자식을 방문한다.

### 후위 순회 (Postorer Traversal)

    하나의 노드에 방문했을 때 다음의 순서를 따른다.

    1. 왼쪽 자식을 방문한다.
    2. 오른쪽 자식을 방문한다.
    3. 자기 자신을 처리한다.

![image](https://user-images.githubusercontent.com/29271126/88507705-f915c480-d017-11ea-85d9-124022cc11cc.png)

예를 들어 위 예제를 이용한 방문 순서는 다음과 같다

### 전위 순회

1 - 2 - 4 - 8 - 9 - 5 - 10 - 11 - 3 - 6 - 12 - 13 - 7 - 14 - 15

### 중위 순회

8 - 4 - 9 - 2 - 10 - 5 - 11 - 1 - 12 - 6 - 13 - 3 - 14 - 7 - 15

### 후휘 순회

8 - 9 - 4 - 10 - 11 - 5 - 2 - 12 - 13 - 6 - 14 - 15 - 7 - 3 - 1

---

[[소스 확인]](https://github.com/flexboni/algorithm_c/blob/master/20강/binarTree.cpp)

---