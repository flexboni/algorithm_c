# 합집합 찾기(Union Find)

[[자세한 설명 보기]](https://blog.naver.com/ndb796/221230945092)

**합집합 찾기(Union Find)** 은 대표적인 '그래프' 알고리즘이다. 서로소 집합(Disjoint-Set) 알고리즘이라고도 부른다. 구체적으로 _여러 개의 노드가 존재할 때 두 개의 노드를 선택해서, 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘_ 이다.

여러 개의 노드가 서로 자유분방하게 존재한다고 생각해보자. 이와 같이 모두 연결되지 않고 각자 자기 자신만을 집합의 원소로 가지고 있을 때 '모든 값이 자기 자신'을 가리킨다.

|노드번호|1|2|3|4|5|6|7|8|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|부모 노드 번호|1|2|3|4|5|6|7|8|

만약 1과 2가 연결되었다고 해보자.

|노드번호|1|2|3|4|5|6|7|8|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|부모 노드 번호|1|1|3|4|5|6|7|8|

위의 표 처럼 1과 2의 부모 노드 번호가 동일하다. 이렇게 _부모를 합칠 때는 일반적으로 더 작은 값 쪽으로 합친다._ 바로 이것을 **합칩(Union)** 이라고 한다.

또 이러한 '연결성'을 우리가 프로그래밍 언어로 어떻게 표현할수 있을 지애 대한 내용이 바로 Union-Find 라고 생각하면 이해가 쉽다.

만약 2와 3이 연결되었다고 해보자.

|노드번호|1|2|3|4|5|6|7|8|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|부모 노드 번호|1|1|2|4|5|6|7|8|

위와 같이 표현되는데, 1과 3이 연결되어 있는 상황에서 어떻게 파악할 수 있을까? 1과 3은 부모가 각각 1과 2로 다르기 때문에 부모 노드만 보고는 한번에 파악할 수 없다. 이러한 문제를 해결하기 위해 **'재귀 함수'** 가 사용된다.

3의 부모를 찾기 위해서 먼저 3이 가리키고 있는 2를 찾는다. 그러면 2의 부모가 1을 가리키고 있으므로 그제서야 3의 부모는 1이라는 것을 파악할 수 있다. 이러한 과증은 재귀적으로 수행될 때 가장 효과적이고 직관적으로 언어를 작성할 수 있다.

|노드번호|1|2|3|4|5|6|7|8|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|부모 노드 번호|1|1|1|4|5|6|7|8|

최종적으로는 위 표와 같이 표현이 된다. 노드 1, 2, 3의 부모가 모두 1이기 때문에 이 세가지 노드는 모두 같은 그래프에 속해 있다고 할 수 있다. 이것이 바로 Union-Find 의 전부이다.

**Find 알고리즘** 은 _두 개의 노드의 부모 노드를 확인하여 현재 같은 집합에 속하는지 확인하는 알고리즘_ 이다.

---

[[소스 확인]](https://github.com/flexboni/algorithm_c/blob/master/18강/unionFind.cpp)

---